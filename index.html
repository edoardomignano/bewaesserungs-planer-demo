<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PVC WELT Bew√§sserungsplaner Demo v0.7</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#121926; --muted:#9aa4b2; --text:#e6edf3;
      --accent:#4cc9f0; --warn:#fbbf24; --ok:#34d399; --bad:#fb7185; --vio:#a78bfa;
    }
    *{box-sizing:border-box;}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text);}
    header{padding:12px 16px;border-bottom:1px solid rgba(255,255,255,.08);display:flex;align-items:center;justify-content:space-between;gap:12px;}
    .title{font-weight:950;letter-spacing:.2px;}
    .sub{color:var(--muted);font-size:12px;margin-top:2px;}
    .wrap{display:grid;grid-template-columns:380px 1fr 340px;gap:12px;padding:12px;height:calc(100vh - 54px);}
    .panel{background:var(--panel);border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:12px;overflow:auto;}
    canvas{width:100%;height:100%;background:#070a10;border-radius:14px;border:1px solid rgba(255,255,255,.08);}
    h3{margin:0 0 10px;font-size:14px;color:#dbe7ff;}
    .hint{font-size:12px;color:var(--muted);line-height:1.35;}
    .sep{height:1px;background:rgba(255,255,255,.08);margin:12px 0;}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:8px 0;}
    label{font-size:12px;color:var(--muted);}
    input,select,button{
      background:#0f1520;color:var(--text);
      border:1px solid rgba(255,255,255,.12);
      border-radius:10px;padding:8px 10px;font-size:13px;
    }
    input[type="number"]{width:120px;}
    input[type="text"]{width:100%;}
    button{cursor:pointer;}
    button.primary{background:linear-gradient(135deg, rgba(76,201,240,.25), rgba(76,201,240,.08));border-color:rgba(76,201,240,.35);}
    button.warn{background:linear-gradient(135deg, rgba(251,191,36,.25), rgba(251,191,36,.08));border-color:rgba(251,191,36,.35);}
    button.ok{background:linear-gradient(135deg, rgba(52,211,153,.25), rgba(52,211,153,.08));border-color:rgba(52,211,153,.35);}
    button.vio{background:linear-gradient(135deg, rgba(167,139,250,.25), rgba(167,139,250,.08));border-color:rgba(167,139,250,.35);}
    button:disabled{opacity:.45;cursor:not-allowed;}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}

    .step{
      display:flex;align-items:flex-start;justify-content:space-between;gap:10px;
      padding:10px;border:1px solid rgba(255,255,255,.08);border-radius:12px;margin:8px 0;
      background:rgba(0,0,0,.18);
      cursor:pointer; user-select:none;
      transition:transform .05s ease, border-color .1s ease;
    }
    .step:hover{border-color:rgba(76,201,240,.25);}
    .step:active{transform:scale(0.995);}
    .step .sTitle{font-weight:900;font-size:13px;}
    .step .sText{font-size:12px;color:var(--muted);margin-top:4px;line-height:1.3;}
    .badge{font-size:11px;padding:3px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);color:var(--muted);}
    .badge.open{border-color:rgba(251,191,36,.35);color:rgba(251,191,36,.95);}
    .badge.ok{border-color:rgba(52,211,153,.35);color:rgba(52,211,153,.95);}

    .kpi{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px;}
    .card{border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px;background:rgba(0,0,0,.18);}
    .card .k{color:var(--muted);font-size:12px;}
    .card .v{font-size:18px;font-weight:950;margin-top:4px;}

    .list{margin:8px 0 0;padding:0;list-style:none;}
    .list li{padding:8px;border:1px solid rgba(255,255,255,.08);border-radius:12px;margin:8px 0;display:flex;justify-content:space-between;gap:10px;}
    .small{font-size:12px;color:var(--muted);}

    .zoneItem{border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px;background:rgba(0,0,0,.18);margin:10px 0;}
    .zoneHead{display:flex;justify-content:space-between;align-items:center;gap:8px;}

    /* Bottom bar */
    #bottomBar{
      position:fixed;left:12px;right:12px;bottom:12px;
      background:rgba(18,25,38,.92);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:10px 12px;
      display:flex;gap:10px;align-items:center;justify-content:space-between;
      z-index:9999;
      backdrop-filter: blur(6px);
    }
    #bottomBar .btitle{font-weight:900;}
    #bottomBar .bsub{font-size:12px;color:var(--muted);}
  </style>
</head>
<body>
<header>
  <div>
    <div class="title">PVC WELT Bew√§sserungsplaner Demo <span class="mono">v0.7</span></div>
    <div class="sub">Kinderleicht ‚Ä¢ Live-Regner-Preview ‚Ä¢ N√§ssekarte (Blau) ‚Ä¢ Auto-Rohre ‚Ä¢ PDF-Materialliste</div>
  </div>
  <div class="row">
    <button class="primary" id="btnExportJson">Export (JSON)</button>
    <button id="btnImportJson">Import</button>
    <input id="fileImport" type="file" accept="application/json" hidden />
  </div>
</header>

<div class="wrap">
  <!-- LEFT -->
  <div class="panel">
    <h3>Schritt f√ºr Schritt</h3>
    <div class="hint">Klick auf einen Schritt = Tool aktiv. Jeder Schritt ist kurz erkl√§rt.</div>
    <div id="steps"></div>

    <div class="sep"></div>

    <h3>Aktionen</h3>
    <div class="row">
      <button id="btnUndoSpr" class="warn">‚Ü© Letzten Regner r√ºckg√§ngig</button>
      <button id="btnClearSpr" class="warn">Regner l√∂schen</button>
      <button id="btnFitView" class="primary">Bild: Fit</button>
    </div>
    <div class="row">
      <button id="btnToggleWet" class="primary">N√§ssekarte: AN</button>
      <button id="btnToggleGrid">Raster: AUS</button>
      <button id="btnRecalc" class="primary">Neu berechnen</button>
    </div>

    <div class="sep"></div>

    <h3>N√§ssekarte (Erkl√§rung)</h3>
    <div class="hint">
      <div><b>Hellblau</b> = Fl√§che wird bew√§ssert</div>
      <div><b>Dunkelblau</b> = doppelt/mehrfach bew√§ssert</div>
    </div>

    <div class="kpi">
      <div class="card"><div class="k">Bew√§sserte Fl√§che (ca.)</div><div class="v" id="kpiWet">‚Äì</div></div>
      <div class="card"><div class="k">√úberlappung (ca.)</div><div class="v" id="kpiOverlap">‚Äì</div></div>
      <div class="card"><div class="k">Regner</div><div class="v" id="kpiSpr">‚Äì</div></div>
      <div class="card"><div class="k">Rohre</div><div class="v" id="kpiPipe">‚Äì</div></div>
    </div>

    <div class="sep"></div>

    <h3>Materialliste (Demo)</h3>
    <ul class="list" id="bom"></ul>
  </div>

  <!-- CENTER -->
  <div class="panel" style="padding:10px;">
    <canvas id="c"></canvas>
  </div>

  <!-- RIGHT -->
  <div class="panel">
    <h3>Aktueller Schritt</h3>
    <div class="card">
      <div class="k" id="curStepTitle">‚Äì</div>
      <div class="small" id="curStepText">‚Äì</div>
    </div>

    <div class="sep"></div>

    <h3>Eigenschaften (nur wenn ausgew√§hlt)</h3>
    <div id="propsNone" class="hint">Nichts ausgew√§hlt. Tipp: Regner einfach anklicken und ziehen.</div>

    <div id="propsScale" style="display:none;">
      <div class="row">
        <label>L√§nge in Meter</label>
        <input id="scaleMeters" type="number" min="0.1" step="0.1" value="5" />
        <button id="btnApplyScale" class="primary">Anwenden</button>
      </div>
      <div class="hint">Beispiel: Klicke zwei Punkte mit bekannter L√§nge und gib die echte L√§nge in Metern ein.</div>
    </div>

    <div id="propsSource" style="display:none;">
      <div class="row"><label>Name</label><input id="srcName" type="text" /></div>
      <div class="row"><label>Info</label><input id="srcInfo" type="text" /></div>
      <div class="row"><button id="btnDeleteSource" class="warn">Quelle l√∂schen</button></div>
    </div>

    <div id="propsSpr" style="display:none;">
      <div class="row"><label>Name</label><input id="sprName" type="text" /></div>
      <div class="row">
        <label>Variante</label>
        <select id="sprPreset"></select>
      </div>
      <div class="row"><label>Radius (m)</label><input id="sprRadius" type="number" min="0.2" step="0.1" /></div>
      <div class="row"><label>Winkel (¬∞)</label><input id="sprArc" type="number" min="30" max="360" step="1" /></div>
      <div class="row"><label>Richtung (¬∞)</label><input id="sprDir" type="number" min="0" max="359" step="1" /></div>
      <div class="row">
        <label>Zone</label>
        <select id="sprZone"></select>
      </div>
      <div class="row">
        <button id="btnDeleteSpr" class="warn">Regner l√∂schen</button>
        <button id="btnCopySpr" class="primary">Duplizieren</button>
      </div>
      <div class="hint">Regner kannst du jederzeit mit gedr√ºckter Maus verschieben.</div>
    </div>

    <div id="propsPipe" style="display:none;">
      <div class="row"><label>Name</label><input id="pipeName" type="text" /></div>
      <div class="row"><label>Durchmesser (mm)</label><input id="pipeDia" type="number" step="1" /></div>
      <div class="row"><button id="btnDeletePipe" class="warn">Rohr l√∂schen</button></div>
    </div>

    <div class="sep"></div>

    <h3>Zonen (Ventilkreise)</h3>
    <div class="row">
      <button id="btnAddZone" class="ok">+ Zone</button>
    </div>
    <div id="zonesList"></div>

    <div class="sep"></div>
    <h3>Shortcuts</h3>
    <div class="hint">
      <div><span class="mono">Mausrad</span> Zoom</div>
      <div><span class="mono">Space</span> Pan (ziehen)</div>
      <div><span class="mono">Esc</span> Abbrechen</div>
      <div><span class="mono">Doppelklick</span> Linie/Polygon beenden</div>
      <div><span class="mono">Strg/Cmd+Z</span> Letzten Regner r√ºckg√§ngig</div>
    </div>
  </div>
</div>

<!-- Bottom Export Bar -->
<div id="bottomBar">
  <div style="display:flex;flex-direction:column;gap:2px;">
    <div class="btitle">Export</div>
    <div class="bsub">Materialliste als PDF drucken (Browser: ‚ÄûAls PDF speichern‚Äú)</div>
  </div>
  <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
    <button id="btnPdfBom" class="primary" style="padding:9px 12px;border-radius:12px;">üìÑ PDF Materialliste</button>
  </div>
</div>

<script>
(() => {
  const APP_VERSION = "PVC WELT Bew√§sserungsplaner Demo v0.7";

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const el = (id)=>document.getElementById(id);
  const uid = ()=>Math.random().toString(16).slice(2)+Date.now().toString(16);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dist = (a,b)=>Math.hypot(a.x-b.x,a.y-b.y);

  // View
  let view = { x: 20, y: 20, s: 1 };
  let cssW=1000, cssH=700;
  function worldToScreen(p){ return { x:(p.x+view.x)*view.s, y:(p.y+view.y)*view.s }; }
  function screenToWorld(p){ return { x:p.x/view.s - view.x, y:p.y/view.s - view.y }; }

  function fitCanvas(){
    const rect = canvas.getBoundingClientRect();
    cssW = Math.max(900, Math.floor(rect.width));
    cssH = Math.max(600, Math.floor(rect.height));
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(cssW*dpr);
    canvas.height = Math.floor(cssH*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    render();
  }
  window.addEventListener('resize', fitCanvas);

  // Demo Presets (sp√§ter CSV)
  const PRESETS = [
    { key:"S3",  label:"Demo S (3.0m)",  radiusM:3.0,  lpm:1.6 },
    { key:"M4",  label:"Demo M (4.0m)",  radiusM:4.0,  lpm:2.2 },
    { key:"L6",  label:"Demo L (6.0m)",  radiusM:6.0,  lpm:3.5 },
    { key:"XL9", label:"Demo XL (9.0m)", radiusM:9.0,  lpm:5.5 },
    { key:"CUSTOM", label:"Custom",      radiusM:6.0,  lpm:3.5 },
  ];
  const presetByKey = (k)=>PRESETS.find(p=>p.key===k) || PRESETS[2];

  // State
  const state = {
    version: APP_VERSION,
    bg: { img:null, w:0, h:0, url:null },
    scale: { pxPerMeter:null, a:null, b:null }, // 2 Punkte
    source: null, // {id,name,info,x,y}
    areas: [],    // {id,name,pts}
    pipes: [],    // {id,name,dia,pts}
    sprinklers: [], // {id,presetKey,name,x,y,radiusM,arcDeg,dirDeg,zoneId}
    zones: [],    // {id,name,maxLpm}
    selection: null,
    showWet: true,
    showGrid: false,

    wet: { ready:false, cellPx: 12, data:null, bbox:null }, // overlap count
    sprUndoStack: [],

    defaultSpr: { presetKey:"L6", name:"Regner", radiusM:6.0, arcDeg:360, dirDeg:0, zoneId:null }
  };

  function ensureZones(){
    if(state.zones.length===0) state.zones.push({id:uid(), name:"Zone 1", maxLpm:20});
    if(!state.defaultSpr.zoneId) state.defaultSpr.zoneId = state.zones[0].id;
  }
  ensureZones();

  // Tools
  let tool = 'pan'; // pan, scale, source, area, sprinkler, pipe
  let drawing = { kind:null, pts:[], temp:null, snap:null };
  let mouse = { down:false, x:0, y:0, last:null };
  let spacePan = false;

  // Live sprinkler placing
  let liveSpr = null; // {active, id?, data}
  let dragging = null; // {kind:'sprinkler'|'source', id}

  // Helpers
  const SNAP_RADIUS_WORLD = () => 18 / view.s;
  const closeThresholdWorld = () => 14 / view.s;

  function escapeHtml(str){
    return String(str)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function polyBBox(pts){
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    for(const p of pts){ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); }
    return {minX,minY,maxX,maxY};
  }
  function pointInPoly(pt, poly){
    let inside=false;
    for(let i=0,j=poly.length-1;i<poly.length;j=i++){
      const xi=poly[i].x, yi=poly[i].y;
      const xj=poly[j].x, yj=poly[j].y;
      const intersect=((yi>pt.y)!=(yj>pt.y)) && (pt.x < (xj-xi)*(pt.y-yi)/(yj-yi+1e-9)+xi);
      if(intersect) inside=!inside;
    }
    return inside;
  }
  function getAreaMask(pt){
    if(state.areas.length===0) return true;
    for(const a of state.areas){
      if(a.pts?.length>=3 && pointInPoly(pt,a.pts)) return true;
    }
    return false;
  }

  function nearestSnapPoint(w){
    const candidates = [];
    if(state.source) candidates.push({kind:'source', x:state.source.x, y:state.source.y});
    for(const s of state.sprinklers) candidates.push({kind:'sprinkler', x:s.x, y:s.y});
    let best=null, bestD=Infinity;
    for(const c of candidates){
      const d=Math.hypot(w.x-c.x,w.y-c.y);
      if(d<bestD){bestD=d;best=c;}
    }
    if(best && bestD<=SNAP_RADIUS_WORLD()) return {...best,d:bestD};
    return null;
  }

  // Hit test
  function hitTest(w){
    for(let i=state.sprinklers.length-1;i>=0;i--){
      const s=state.sprinklers[i];
      if(Math.hypot(w.x-s.x,w.y-s.y) < 12/view.s) return {kind:'sprinkler', id:s.id};
    }
    if(state.source && Math.hypot(w.x-state.source.x,w.y-state.source.y) < 14/view.s){
      return {kind:'source', id:state.source.id};
    }
    for(let i=state.pipes.length-1;i>=0;i--){
      const p=state.pipes[i];
      if(p.pts?.length>=2 && isNearPolyline(w,p.pts, 10/view.s)) return {kind:'pipe', id:p.id};
    }
    for(let i=state.areas.length-1;i>=0;i--){
      const a=state.areas[i];
      if(a.pts?.length>=3 && pointInPoly(w,a.pts)) return {kind:'area', id:a.id};
    }
    return null;
  }
  function distToSegment(p,a,b){
    const vx=b.x-a.x, vy=b.y-a.y;
    const wx=p.x-a.x, wy=p.y-a.y;
    const c1=wx*vx+wy*vy;
    if(c1<=0) return Math.hypot(p.x-a.x,p.y-a.y);
    const c2=vx*vx+vy*vy;
    if(c2<=c1) return Math.hypot(p.x-b.x,p.y-b.y);
    const t=c1/c2;
    const px=a.x+t*vx, py=a.y+t*vy;
    return Math.hypot(p.x-px,p.y-py);
  }
  function isNearPolyline(pt, pts, tol){
    for(let i=0;i<pts.length-1;i++){
      if(distToSegment(pt, pts[i], pts[i+1]) <= tol) return true;
    }
    return false;
  }

  // Selection getters
  function getSel(kind){
    if(state.selection?.kind!==kind) return null;
    if(kind==='sprinkler') return state.sprinklers.find(s=>s.id===state.selection.id)||null;
    if(kind==='pipe') return state.pipes.find(p=>p.id===state.selection.id)||null;
    if(kind==='source') return (state.source && state.source.id===state.selection.id) ? state.source : null;
    if(kind==='area') return state.areas.find(a=>a.id===state.selection.id)||null;
    return null;
  }

  // Steps
  function stepStatus(){
    return {
      s1: !!state.bg.img,
      s2: !!state.scale.pxPerMeter,
      s3: !!state.source,
      s4: state.areas.length>0,
      s5: state.sprinklers.length>0,
      s6: state.pipes.length>0
    };
  }

  const STEP_DEFS = [
    {
      key:"s1",
      title:"1) Bild hochladen",
      text:"W√§hle ein Bild. Danach auf ‚ÄûFit‚Äú klicken.",
      tool:null
    },
    {
      key:"s2",
      title:"2) Ma√üstab setzen",
      text:"Klicke zwei Punkte mit bekannter L√§nge. Dann L√§nge in Meter eingeben und ‚ÄûAnwenden‚Äú. ",
      tool:"scale"
    },
    {
      key:"s3",
      title:"3) Wasserquelle setzen",
      text:"Klicke im Plan auf die Stelle, wo das Wasser startet (Wasserhahn).",
      tool:"source"
    },
    {
      key:"s4",
      title:"4) Zu bew√§ssernde Fl√§che markieren",
      text:"Zeichne ein Polygon um die Fl√§che, die Wasser bekommen soll. Doppelklick beendet.",
      tool:"area"
    },
    {
      key:"s5",
      title:"5) Regner setzen",
      text:"Maus gedr√ºckt halten = Vorschau. Bewege und lass los zum Setzen. Regner sp√§ter einfach ziehen.",
      tool:"sprinkler"
    },
    {
      key:"s6",
      title:"6) Rohre verlegen",
      text:"Entweder zeichnen (Doppelklick beendet) oder ‚ÄûAuto-Rohre‚Äú nutzen.",
      tool:"pipe"
    }
  ];

  function setTool(t){
    tool = t || 'pan';
    updateCurStepBox();
    showProps();
    renderSteps();
    render();
  }

  function updateCurStepBox(){
    const s = STEP_DEFS.find(x=>x.tool===tool) || STEP_DEFS[0];
    el('curStepTitle').textContent = s ? s.title : "‚Äì";
    el('curStepText').textContent = s ? s.text : "‚Äì";
  }

  function renderSteps(){
    const st = stepStatus();
    const wrap = el('steps');
    wrap.innerHTML = "";

    // Step 1 includes upload controls
    const s1 = document.createElement('div');
    s1.className='step';
    s1.innerHTML = `
      <div style="flex:1;">
        <div class="sTitle">${STEP_DEFS[0].title}</div>
        <div class="sText">${STEP_DEFS[0].text}</div>
        <div class="row" style="margin-top:10px;">
          <input id="fileBg" type="file" accept="image/*" style="max-width:220px;" />
          <button id="btnFitView2" class="primary" type="button">Fit</button>
        </div>
      </div>
      <div>${st.s1 ? `<span class="badge ok">OK</span>` : `<span class="badge open">OFFEN</span>`}</div>
    `;
    wrap.appendChild(s1);

    // Steps 2..6
    for(const s of STEP_DEFS.slice(1)){
      const div=document.createElement('div');
      div.className='step';
      const ok = st[s.key];
      div.innerHTML = `
        <div style="flex:1;">
          <div class="sTitle">${s.title}</div>
          <div class="sText">${s.text}</div>
        </div>
        <div>${ok ? `<span class="badge ok">OK</span>` : `<span class="badge open">OFFEN</span>`}</div>
      `;
      div.addEventListener('click', ()=> setTool(s.tool));
      wrap.appendChild(div);
    }

    // Wire upload
    const fileBg = document.getElementById('fileBg');
    const btnFit2 = document.getElementById('btnFitView2');
    if(fileBg){
      fileBg.onchange = (e)=>handleBgUpload(e);
    }
    if(btnFit2){
      btnFit2.onclick = ()=>{ fitImageToView(); render(); };
    }
  }

  // Background upload
  function handleBgUpload(e){
    const file = e.target.files?.[0];
    if(!file) return;
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>{
      state.bg.img = img; state.bg.w=img.width; state.bg.h=img.height; state.bg.url=url;
      fitImageToView();
      // kinderleicht: direkt Ma√üstab als n√§chster Schritt
      setTool('scale');
      recalcWet();
      buildBOM();
      renderSteps();
      render();
    };
    img.src = url;
  }

  function fitImageToView(){
    if(!state.bg.img) return;
    const vw=cssW, vh=cssH;
    const sx=(vw*0.9)/state.bg.w;
    const sy=(vh*0.9)/state.bg.h;
    view.s = clamp(Math.min(sx,sy), 0.2, 6);
    const cx=state.bg.w/2, cy=state.bg.h/2;
    view.x = (vw/(2*view.s)) - cx;
    view.y = (vh/(2*view.s)) - cy;
  }
  el('btnFitView').addEventListener('click', ()=>{ fitImageToView(); render(); });

  // Zones
  function zoneTotals(){
    const totals = new Map();
    for(const z of state.zones) totals.set(z.id, 0);
    for(const s of state.sprinklers){
      const zid = s.zoneId || state.zones[0].id;
      const pr = presetByKey(s.presetKey);
      const arcFactor = (s.arcDeg||360)/360;
      totals.set(zid, (totals.get(zid)||0) + pr.lpm*arcFactor);
    }
    return totals;
  }
  function renderZones(){
    ensureZones();
    const list = el('zonesList');
    list.innerHTML='';
    const totals = zoneTotals();

    state.zones.forEach((z, idx)=>{
      const t = totals.get(z.id)||0;
      const div=document.createElement('div');
      div.className='zoneItem';
      div.innerHTML=`
        <div class="zoneHead">
          <div style="font-weight:950;">${escapeHtml(z.name)}</div>
          <button class="warn" data-del="${z.id}" style="padding:6px 10px;font-size:12px;">L√∂schen</button>
        </div>
        <div class="row" style="margin-top:8px;">
          <label>Max L/min</label>
          <input type="number" step="1" data-max="${z.id}" value="${z.maxLpm}" />
        </div>
        <div class="hint">Aktuell (gesch√§tzt): <b>${t.toFixed(1)} L/min</b> ${t>z.maxLpm ? "‚ö†Ô∏è zu hoch" : "‚úÖ ok"}</div>
      `;
      div.querySelector(`[data-del="${z.id}"]`).addEventListener('click', ()=>{
        if(state.zones.length<=1){ alert("Mindestens 1 Zone muss bleiben."); return; }
        state.zones = state.zones.filter(x=>x.id!==z.id);
        const fallback = state.zones[0].id;
        for(const s of state.sprinklers) if(s.zoneId===z.id) s.zoneId=fallback;
        if(state.defaultSpr.zoneId===z.id) state.defaultSpr.zoneId=fallback;
        renderZones();
        updateSprZoneOptions();
        buildBOM(); recalcWet(); render();
      });
      div.querySelector(`[data-max="${z.id}"]`).addEventListener('input', (e)=>{
        z.maxLpm = parseFloat(e.target.value||"0");
        renderZones();
      });
      list.appendChild(div);
    });
  }

  el('btnAddZone').addEventListener('click', ()=>{
    state.zones.push({id:uid(), name:`Zone ${state.zones.length+1}`, maxLpm:20});
    if(!state.defaultSpr.zoneId) state.defaultSpr.zoneId = state.zones[0].id;
    renderZones();
    updateSprZoneOptions();
    render();
  });

  function updateSprZoneOptions(){
    const sel = el('sprZone');
    sel.innerHTML='';
    for(const z of state.zones){
      const opt=document.createElement('option');
      opt.value=z.id;
      opt.textContent=z.name;
      sel.appendChild(opt);
    }
    const s = getSel('sprinkler');
    sel.value = s ? (s.zoneId || state.zones[0].id) : (state.defaultSpr.zoneId || state.zones[0].id);
  }

  // Fill preset select
  function fillPresetSelect(){
    const sel=el('sprPreset');
    sel.innerHTML='';
    for(const p of PRESETS){
      const opt=document.createElement('option');
      opt.value=p.key; opt.textContent=p.label;
      sel.appendChild(opt);
    }
  }

  // Properties show/hide
  function showProps(){
    const sel=state.selection;
    el('propsNone').style.display = sel ? 'none' : 'block';
    el('propsScale').style.display = (tool==='scale' && state.scale.a && state.scale.b) ? 'block' : 'none';
    el('propsSource').style.display = (sel?.kind==='source') ? 'block' : 'none';
    el('propsSpr').style.display = (sel?.kind==='sprinkler') ? 'block' : 'none';
    el('propsPipe').style.display = (sel?.kind==='pipe') ? 'block' : 'none';

    if(sel?.kind==='source') syncSourceForm();
    if(sel?.kind==='sprinkler') syncSprForm();
    if(sel?.kind==='pipe') syncPipeForm();
    updateSprZoneOptions();
  }

  function syncSourceForm(){
    const s=getSel('source'); if(!s) return;
    el('srcName').value=s.name||"";
    el('srcInfo').value=s.info||"";
  }
  function syncSprForm(){
    const s=getSel('sprinkler'); if(!s) return;
    el('sprName').value=s.name||"";
    el('sprPreset').value=s.presetKey||"L6";
    el('sprRadius').value=s.radiusM||6;
    el('sprArc').value=s.arcDeg||360;
    el('sprDir').value=s.dirDeg||0;
    el('sprZone').value=s.zoneId || state.zones[0].id;
  }
  function syncPipeForm(){
    const p=getSel('pipe'); if(!p) return;
    el('pipeName').value=p.name||"";
    el('pipeDia').value=p.dia||25;
  }

  // Apply scale
  el('btnApplyScale').addEventListener('click', ()=>{
    if(!state.scale.a || !state.scale.b) return;
    const meters=parseFloat(el('scaleMeters').value||"1");
    const dpx=dist(state.scale.a,state.scale.b);
    if(meters>0 && dpx>0){
      state.scale.pxPerMeter = dpx/meters;
      recalcWet();
      renderSteps();
      // n√§chster Schritt: Quelle
      setTool('source');
      render();
    }
  });

  // Source edits
  el('srcName').addEventListener('input', ()=>{
    const s=getSel('source'); if(!s) return;
    s.name=el('srcName').value||s.name;
    buildBOM(); render();
  });
  el('srcInfo').addEventListener('input', ()=>{
    const s=getSel('source'); if(!s) return;
    s.info=el('srcInfo').value||"";
    render();
  });
  el('btnDeleteSource').addEventListener('click', ()=>{
    state.source=null;
    if(state.selection?.kind==='source') state.selection=null;
    buildBOM(); recalcWet(); renderSteps(); showProps(); render();
  });

  // Sprinkler edits
  el('sprName').addEventListener('input', ()=>{
    const s=getSel('sprinkler'); if(!s) return;
    s.name=el('sprName').value||s.name;
    buildBOM(); render();
  });
  el('sprPreset').addEventListener('change', ()=>{
    const s=getSel('sprinkler'); if(!s) return;
    const val=el('sprPreset').value;
    const pr=presetByKey(val);
    s.presetKey=val;
    if(val!=="CUSTOM"){
      s.radiusM=pr.radiusM;
      s.name=`Regner ${pr.label}`;
    }
    syncSprForm();
    renderZones(); buildBOM(); recalcWet(); render();
  });
  el('sprRadius').addEventListener('input', ()=>{
    const s=getSel('sprinkler'); if(!s) return;
    s.radiusM=clamp(parseFloat(el('sprRadius').value||"6"),0.2,200);
    if(s.presetKey!=="CUSTOM"){ s.presetKey="CUSTOM"; el('sprPreset').value="CUSTOM"; }
    recalcWet(); render();
  });
  el('sprArc').addEventListener('input', ()=>{
    const s=getSel('sprinkler'); if(!s) return;
    s.arcDeg=clamp(parseFloat(el('sprArc').value||"360"),30,360);
    recalcWet(); renderZones(); render();
  });
  el('sprDir').addEventListener('input', ()=>{
    const s=getSel('sprinkler'); if(!s) return;
    s.dirDeg=((parseFloat(el('sprDir').value||"0")%360)+360)%360;
    recalcWet(); render();
  });
  el('sprZone').addEventListener('change', ()=>{
    const s=getSel('sprinkler'); if(!s) return;
    s.zoneId=el('sprZone').value;
    renderZones(); buildBOM(); render();
  });
  el('btnDeleteSpr').addEventListener('click', ()=>{
    const s=getSel('sprinkler'); if(!s) return;
    state.sprinklers=state.sprinklers.filter(x=>x.id!==s.id);
    if(state.selection?.id===s.id) state.selection=null;
    renderZones(); buildBOM(); recalcWet(); renderSteps(); showProps(); render();
  });
  el('btnCopySpr').addEventListener('click', ()=>{
    const s=getSel('sprinkler'); if(!s) return;
    const c={...s, id:uid(), x:s.x+20, y:s.y+20};
    state.sprinklers.push(c);
    state.selection={kind:'sprinkler', id:c.id};
    state.sprUndoStack.push({type:'addSpr', id:c.id});
    renderZones(); buildBOM(); recalcWet(); renderSteps(); showProps(); render();
  });

  // Pipe edits
  el('pipeName').addEventListener('input', ()=>{
    const p=getSel('pipe'); if(!p) return;
    p.name=el('pipeName').value||p.name;
    buildBOM(); render();
  });
  el('pipeDia').addEventListener('input', ()=>{
    const p=getSel('pipe'); if(!p) return;
    p.dia=parseInt(el('pipeDia').value||"25",10);
    buildBOM(); render();
  });
  el('btnDeletePipe').addEventListener('click', ()=>{
    const p=getSel('pipe'); if(!p) return;
    state.pipes=state.pipes.filter(x=>x.id!==p.id);
    if(state.selection?.id===p.id) state.selection=null;
    buildBOM(); recalcWet(); renderSteps(); showProps(); render();
  });

  // Toggles
  el('btnToggleWet').addEventListener('click', ()=>{
    state.showWet=!state.showWet;
    el('btnToggleWet').textContent="N√§ssekarte: " + (state.showWet ? "AN" : "AUS");
    render();
  });
  el('btnToggleGrid').addEventListener('click', ()=>{
    state.showGrid=!state.showGrid;
    el('btnToggleGrid').textContent="Raster: " + (state.showGrid ? "AN" : "AUS");
    render();
  });
  el('btnRecalc').addEventListener('click', ()=>{
    recalcWet();
    render();
  });

  // Undo sprinkler
  function undoLastSpr(){
    // remove last added sprinkler action
    for(let i=state.sprUndoStack.length-1;i>=0;i--){
      const a=state.sprUndoStack[i];
      if(a.type==='addSpr'){
        const exists = state.sprinklers.find(s=>s.id===a.id);
        state.sprUndoStack.splice(i,1);
        if(exists){
          state.sprinklers = state.sprinklers.filter(s=>s.id!==a.id);
          if(state.selection?.kind==='sprinkler' && state.selection.id===a.id) state.selection=null;
          renderZones(); buildBOM(); recalcWet(); renderSteps(); showProps(); render();
          return;
        }
      }
    }
  }
  el('btnUndoSpr').addEventListener('click', undoLastSpr);

  // Clear sprinklers
  el('btnClearSpr').addEventListener('click', ()=>{
    if(!confirm("Alle Regner l√∂schen?")) return;
    state.sprinklers=[];
    state.sprUndoStack=[];
    if(state.selection?.kind==='sprinkler') state.selection=null;
    renderZones(); buildBOM(); recalcWet(); renderSteps(); showProps(); render();
  });

  // Keyboard
  window.addEventListener('keydown', (e)=>{
    if(e.code==='Space') spacePan=true;
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z'){
      e.preventDefault();
      undoLastSpr();
    }
    if(e.code==='Escape'){
      drawing={kind:null,pts:[],temp:null,snap:null};
      state.scale.a=null; state.scale.b=null;
      liveSpr=null;
      dragging=null;
      showProps(); render();
    }
  });
  window.addEventListener('keyup', (e)=>{ if(e.code==='Space') spacePan=false; });

  // Canvas events
  canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const zoom = Math.exp(-e.deltaY*0.0012);
    const mx=e.offsetX, my=e.offsetY;
    const before=screenToWorld({x:mx,y:my});
    view.s = clamp(view.s*zoom, 0.2, 6);
    const after=screenToWorld({x:mx,y:my});
    view.x += (after.x-before.x);
    view.y += (after.y-before.y);
    render();
  }, {passive:false});

  canvas.addEventListener('dblclick', ()=>{
    if(tool==='area' && drawing.kind==='area' && drawing.pts.length>=3) finalizeDrawing();
    if(tool==='pipe' && drawing.kind==='pipe' && drawing.pts.length>=2) finalizeDrawing();
  });

  canvas.addEventListener('mousedown', (e)=>{
    mouse.down=true;
    mouse.last={x:e.offsetX,y:e.offsetY};
    const w=screenToWorld({x:e.offsetX,y:e.offsetY});

    // if we clicked an existing sprinkler/source -> drag immediately (always)
    const hit = hitTest(w);
    if(hit && (hit.kind==='sprinkler' || hit.kind==='source')){
      state.selection = hit;
      dragging = {kind:hit.kind, id:hit.id};
      showProps();
      render();
      return;
    }

    if(spacePan || tool==='pan'){
      return;
    }

    if(tool==='scale'){
      if(!state.scale.a) state.scale.a=w;
      else if(!state.scale.b) state.scale.b=w;
      else { state.scale.a=w; state.scale.b=null; state.scale.pxPerMeter=null; }
      showProps(); renderSteps(); render();
      return;
    }

    if(tool==='source'){
      state.source = { id:uid(), name:"Wasserhahn", info:"", x:w.x, y:w.y };
      state.selection = {kind:'source', id:state.source.id};
      buildBOM(); renderSteps(); showProps(); render();
      // next step: Fl√§che
      setTool('area');
      return;
    }

    if(tool==='sprinkler'){
      if(!state.scale.pxPerMeter){ alert("Bitte zuerst Ma√üstab setzen (Schritt 2)."); return; }
      if(!state.source){ alert("Bitte zuerst Wasserquelle setzen (Schritt 3)."); return; }
      ensureZones();

      // Live preview sprinkler (set on mouseup)
      const pr=presetByKey(state.defaultSpr.presetKey);
      liveSpr = {
        active:true,
        data:{
          id:uid(),
          presetKey: state.defaultSpr.presetKey,
          name: state.defaultSpr.name || `Regner ${pr.label}`,
          x:w.x, y:w.y,
          radiusM: state.defaultSpr.radiusM ?? pr.radiusM,
          arcDeg: state.defaultSpr.arcDeg ?? 360,
          dirDeg: state.defaultSpr.dirDeg ?? 0,
          zoneId: state.defaultSpr.zoneId || state.zones[0].id
        }
      };
      render();
      return;
    }

    if(tool==='area' || tool==='pipe'){
      if(!drawing.kind) drawing.kind=tool;
      if(drawing.kind!==tool) drawing={kind:tool, pts:[], temp:null, snap:null};

      let use=w;
      if(tool==='pipe'){
        const snap=nearestSnapPoint(w);
        drawing.snap=snap;
        if(snap) use={x:snap.x,y:snap.y};
      }

      // close on click near first point
      if(drawing.pts.length>=3 && tool==='area' && dist(use,drawing.pts[0])<=closeThresholdWorld()){
        finalizeDrawing(); return;
      }
      if(drawing.pts.length>=2 && tool==='pipe' && dist(use,drawing.pts[0])<=closeThresholdWorld()){
        finalizeDrawing(); return;
      }

      drawing.pts.push(use);
      render();
      return;
    }
  });

  canvas.addEventListener('mousemove', (e)=>{
    mouse.x=e.offsetX; mouse.y=e.offsetY;
    const w=screenToWorld({x:e.offsetX,y:e.offsetY});

    // panning
    if(mouse.down && (spacePan || tool==='pan') && mouse.last){
      const dx=(e.offsetX-mouse.last.x)/view.s;
      const dy=(e.offsetY-mouse.last.y)/view.s;
      view.x+=dx; view.y+=dy;
      mouse.last={x:e.offsetX,y:e.offsetY};
      render();
      return;
    }

    // drag existing
    if(mouse.down && dragging){
      if(dragging.kind==='sprinkler'){
        const s = state.sprinklers.find(x=>x.id===dragging.id);
        if(s){ s.x=w.x; s.y=w.y; recalcWet(); render(); }
      } else if(dragging.kind==='source'){
        if(state.source && state.source.id===dragging.id){ state.source.x=w.x; state.source.y=w.y; render(); }
      }
      return;
    }

    // live sprinkler preview while holding
    if(mouse.down && liveSpr?.active){
      liveSpr.data.x=w.x; liveSpr.data.y=w.y;
      render();
      return;
    }

    // drawing preview
    if(drawing.kind){
      drawing.temp = w;
      if(drawing.kind==='pipe'){
        const snap=nearestSnapPoint(w);
        drawing.snap=snap;
        if(snap) drawing.temp={x:snap.x,y:snap.y};
      } else {
        drawing.snap=null;
      }
      render();
    }
  });

  canvas.addEventListener('mouseup', (e)=>{
    mouse.down=false;
    mouse.last=null;

    // finish drag
    if(dragging){
      dragging=null;
      buildBOM(); renderZones(); render();
      return;
    }

    // place live sprinkler on mouseup
    if(liveSpr?.active){
      const s = liveSpr.data;
      state.sprinklers.push(s);
      state.selection={kind:'sprinkler', id:s.id};
      state.sprUndoStack.push({type:'addSpr', id:s.id});
      liveSpr=null;
      renderZones(); buildBOM(); recalcWet(); renderSteps(); showProps(); render();
      return;
    }
  });

  function finalizeDrawing(){
    const kind=drawing.kind;
    if(!kind) return;

    if(kind==='area'){
      if(drawing.pts.length<3){ drawing={kind:null,pts:[],temp:null,snap:null}; render(); return; }
      const a={id:uid(), name:`Fl√§che ${state.areas.length+1}`, pts:[...drawing.pts]};
      state.areas.push(a);
      state.selection={kind:'area', id:a.id};
      drawing={kind:null,pts:[],temp:null,snap:null};
      recalcWet(); buildBOM(); renderSteps(); showProps(); render();
      // next step: Regner
      setTool('sprinkler');
      return;
    }

    if(kind==='pipe'){
      if(drawing.pts.length<2){ drawing={kind:null,pts:[],temp:null,snap:null}; render(); return; }
      const p={id:uid(), name:`Leitung ${state.pipes.length+1}`, dia:25, pts:[...drawing.pts]};
      state.pipes.push(p);
      state.selection={kind:'pipe', id:p.id};
      drawing={kind:null,pts:[],temp:null,snap:null};
      buildBOM(); recalcWet(); renderSteps(); showProps(); render();
      return;
    }
  }

  // N√§ssekarte (overlap count)
  function recalcWet(){
    state.wet.ready=false;
    state.wet.data=null;
    if(!state.scale.pxPerMeter || state.sprinklers.length===0){
      updateKPIs(null);
      return;
    }

    // bbox from areas if exist else background else sprinkler extent
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    const expand=(p)=>{minX=Math.min(minX,p.x);minY=Math.min(minY,p.y);maxX=Math.max(maxX,p.x);maxY=Math.max(maxY,p.y);};
    if(state.areas.length){
      for(const a of state.areas) for(const p of a.pts) expand(p);
    } else if(state.bg.img){
      expand({x:0,y:0}); expand({x:state.bg.w,y:state.bg.h});
    } else {
      for(const s of state.sprinklers){
        const rpx=s.radiusM*state.scale.pxPerMeter;
        expand({x:s.x-rpx,y:s.y-rpx}); expand({x:s.x+rpx,y:s.y+rpx});
      }
    }
    if(!isFinite(minX)){ updateKPIs(null); return; }

    const cellPx = state.wet.cellPx;
    const w = Math.ceil((maxX-minX)/cellPx);
    const h = Math.ceil((maxY-minY)/cellPx);
    const data = new Uint8Array(w*h);

    let wetCells=0, overlapCells=0;

    for(let j=0;j<h;j++){
      for(let i=0;i<w;i++){
        const cx=minX+(i+0.5)*cellPx;
        const cy=minY+(j+0.5)*cellPx;
        const pt={x:cx,y:cy};
        if(!getAreaMask(pt)) continue;

        let count=0;

        for(const s of state.sprinklers){
          const dx=pt.x-s.x, dy=pt.y-s.y;
          const d=Math.hypot(dx,dy);
          const rpx=s.radiusM*state.scale.pxPerMeter;
          if(d>rpx) continue;

          // arc check
          const arc=(s.arcDeg||360);
          if(arc<359){
            const ang=(Math.atan2(dy,dx)*180/Math.PI+360)%360;
            const dir=(s.dirDeg||0);
            const start=(dir-arc/2+360)%360;
            const end=(dir+arc/2+360)%360;
            const inArc = (start<end) ? (ang>=start && ang<=end) : (ang>=start || ang<=end);
            if(!inArc) continue;
          }

          count++;
          if(count>=4) break; // cap for visualization (4+)
        }

        const idx=j*w+i;
        data[idx]=count;
        if(count>=1) wetCells++;
        if(count>=2) overlapCells++;
      }
    }

    state.wet.data={data,w,h};
    state.wet.bbox={minX,minY,maxX,maxY,cellPx,w,h};
    state.wet.ready=true;

    updateKPIs({wetCells, overlapCells, totalCells:w*h});
  }

  function updateKPIs(info){
    el('kpiSpr').textContent = String(state.sprinklers.length);
    el('kpiPipe').textContent = String(state.pipes.length);

    if(!info){
      el('kpiWet').textContent="‚Äì";
      el('kpiOverlap').textContent="‚Äì";
      return;
    }
    // percentages based on masked cells approximation; totalCells includes non-mask too, but ok as demo
    const wetPct = info.totalCells ? Math.round(info.wetCells/info.totalCells*100) : 0;
    const ovPct  = info.totalCells ? Math.round(info.overlapCells/info.totalCells*100) : 0;
    el('kpiWet').textContent = wetPct + "%";
    el('kpiOverlap').textContent = ovPct + "%";
  }

  // BOM
  function buildBOMRows(){
    const rows=[];
    if(state.source) rows.push({name:"Wasserquelle (Demo)", qty:1});

    for(const z of state.zones) rows.push({name:`Zone/Ventil (Demo): ${z.name}`, qty:1});

    for(const p of state.pipes){
      rows.push({name:`Rohr ${p.dia}mm ‚Äî ${p.name}`, qty:1});
    }

    for(const s of state.sprinklers){
      const pr=presetByKey(s.presetKey);
      rows.push({name:`${pr.label} ‚Äî ${s.name}`, qty:1});
    }

    const map=new Map();
    for(const r of rows) map.set(r.name, (map.get(r.name)||0)+r.qty);

    return [...map.entries()]
      .map(([name,qty])=>({name,qty}))
      .sort((a,b)=>b.qty-a.qty);
  }

  function buildBOM(){
    const items=buildBOMRows();
    const ul=el('bom'); ul.innerHTML="";
    if(items.length===0){
      const li=document.createElement('li');
      li.innerHTML=`<span class="small">Noch keine Teile</span><span class="small">0</span>`;
      ul.appendChild(li);
      return;
    }
    for(const it of items){
      const li=document.createElement('li');
      li.innerHTML=`<span>${escapeHtml(it.name)}<div class="small">Demo</div></span><span style="font-weight:950;">${it.qty}</span>`;
      ul.appendChild(li);
    }
  }

  // PDF print window
  function openBOMPrintWindow(){
    const items=buildBOMRows();
    const now=new Date();
    const dateStr=now.toLocaleDateString("de-DE");
    const timeStr=now.toLocaleTimeString("de-DE",{hour:"2-digit",minute:"2-digit"});

    const projectInfo = [
      state.source ? `Wasserquelle: ${state.source.name}${state.source.info ? " ("+state.source.info+")" : ""}` : "Wasserquelle: ‚Äì",
      state.scale?.pxPerMeter ? "Ma√üstab: gesetzt" : "Ma√üstab: ‚Äì",
      `Fl√§chen: ${state.areas.length}`,
      `Regner: ${state.sprinklers.length}`,
      `Rohre: ${state.pipes.length}`,
      `Version: ${state.version}`
    ];

    const tableRows = items.length
      ? items.map(i=>`
        <tr>
          <td>${escapeHtml(i.name)}</td>
          <td style="text-align:right;font-weight:800;">${i.qty}</td>
        </tr>
      `).join("")
      : `<tr><td colspan="2" style="color:#666;">Noch keine Teile geplant.</td></tr>`;

    const html = `
<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Materialliste ‚Äì PVC WELT Bew√§sserungsplaner</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;margin:24px;color:#111;}
    .head{display:flex;justify-content:space-between;align-items:flex-start;gap:16px;}
    h1{margin:0;font-size:18px;}
    .meta{font-size:12px;color:#444;line-height:1.4;}
    .box{margin-top:14px;border:1px solid #ddd;border-radius:10px;padding:12px;}
    table{width:100%;border-collapse:collapse;margin-top:12px;}
    th,td{border-bottom:1px solid #eee;padding:10px 8px;font-size:13px;vertical-align:top;}
    th{text-align:left;background:#fafafa;}
    .small{font-size:12px;color:#555;}
    .footer{margin-top:14px;font-size:11px;color:#666;}
    @media print{ body{margin:12mm;} .box{break-inside:avoid;} }
  </style>
</head>
<body>
  <div class="head">
    <div>
      <h1>Materialliste ‚Äì PVC WELT Bew√§sserungsplaner</h1>
      <div class="small">Stand: ${dateStr} ${timeStr}</div>
    </div>
    <div class="meta">
      ${projectInfo.map(x=>`<div>${escapeHtml(x)}</div>`).join("")}
    </div>
  </div>

  <div class="box">
    <div style="font-weight:800;margin-bottom:6px;">Ben√∂tigte Artikel (Demo)</div>
    <table>
      <thead>
        <tr><th>Artikel</th><th style="text-align:right;">Menge</th></tr>
      </thead>
      <tbody>${tableRows}</tbody>
    </table>
  </div>

  <div class="footer">
    Hinweis: Im Druckdialog ‚ÄûAls PDF speichern‚Äú w√§hlen.
  </div>

  <script>
    window.onload=()=>{ setTimeout(()=>window.print(), 200); };
  </script>
</body>
</html>`.trim();

    const w = window.open("", "_blank");
    if(!w){ alert("Popup blockiert. Bitte Popups erlauben und erneut versuchen."); return; }
    w.document.open();
    w.document.write(html);
    w.document.close();
  }

  el('btnPdfBom').addEventListener('click', openBOMPrintWindow);

  // Export/Import JSON
  el('btnExportJson').addEventListener('click', ()=>{
    const payload = serialize();
    const blob=new Blob([JSON.stringify(payload,null,2)],{type:"application/json"});
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download=`bewaesserungsplan_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
  });
  el('btnImportJson').addEventListener('click', ()=>el('fileImport').click());
  el('fileImport').addEventListener('change', async (e)=>{
    const file=e.target.files?.[0]; if(!file) return;
    const d=JSON.parse(await file.text());
    await deserialize(d);
    recalcWet(); buildBOM(); renderSteps(); showProps(); renderZones(); render();
    e.target.value="";
  });

  function serialize(){
    return {
      version: state.version,
      bg: { w: state.bg.w, h: state.bg.h },
      scale: state.scale,
      source: state.source,
      areas: state.areas,
      pipes: state.pipes,
      sprinklers: state.sprinklers,
      zones: state.zones,
      defaultSpr: state.defaultSpr,
      wet: { cellPx: state.wet.cellPx },
    };
  }

  async function deserialize(d){
    state.scale = d.scale || {pxPerMeter:null,a:null,b:null};
    state.source = d.source || null;
    state.areas = d.areas || [];
    state.pipes = d.pipes || [];
    state.sprinklers = d.sprinklers || [];
    state.zones = d.zones || [];
    state.defaultSpr = d.defaultSpr || state.defaultSpr;
    state.wet.cellPx = d.wet?.cellPx || 12;
    state.selection=null;
    state.sprUndoStack=[];
    ensureZones();
    updateCurStepBox();
  }

  // Auto-Rohre (Demo): Quelle ‚Üí n√§chster Regner ‚Üí n√§chster Regner ...
  function autoPipes(){
    if(!state.source){ alert("Bitte zuerst Wasserquelle setzen."); return; }
    if(state.sprinklers.length===0){ alert("Bitte zuerst Regner setzen."); return; }

    const remaining = new Set(state.sprinklers.map(s=>s.id));
    let current = {x:state.source.x, y:state.source.y};
    const pts = [{x:current.x, y:current.y}];

    while(remaining.size){
      let best=null, bestD=Infinity;
      for(const id of remaining){
        const s = state.sprinklers.find(x=>x.id===id);
        const d = Math.hypot(s.x-current.x, s.y-current.y);
        if(d<bestD){bestD=d; best=s;}
      }
      if(!best) break;
      pts.push({x:best.x, y:best.y});
      current = {x:best.x, y:best.y};
      remaining.delete(best.id);
    }

    state.pipes.push({
      id:uid(),
      name:`Auto-Leitung ${state.pipes.length+1}`,
      dia:25,
      pts
    });

    buildBOM(); recalcWet(); renderSteps(); render();
  }

  // Steps: add button for Auto-Rohre inside Step 6 description (right side already explains)
  // We'll place a helper button in the left actions area by hijacking step 6 click text:
  // (Keep UI minimal: use a confirm button in step list via renderSteps enhancement)
  // Simple: use an extra button in Step 6 box after render.
  function injectAutoPipeButton(){
    // Find last step node and add a small button row if not exists
    const nodes = el('steps').querySelectorAll('.step');
    const last = nodes[nodes.length-1];
    if(!last) return;
    // avoid duplicates
    if(last.querySelector('#btnAutoPipesInline')) return;

    const mini = document.createElement('div');
    mini.className='row';
    mini.style.marginTop='10px';
    mini.innerHTML = `
      <button id="btnAutoPipesInline" class="vio" type="button">üß© Auto-Rohre verbinden</button>
    `;
    last.querySelector('div[style*="flex:1"]').appendChild(mini);
    last.querySelector('#btnAutoPipesInline').addEventListener('click', (ev)=>{
      ev.stopPropagation();
      autoPipes();
    });
  }

  // Drawing & rendering primitives
  function drawLine(a,b,color,lw){
    const p1=worldToScreen(a), p2=worldToScreen(b);
    ctx.save(); ctx.strokeStyle=color; ctx.lineWidth=lw;
    ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
    ctx.restore();
  }
  function drawPoint(p,color,r=5){
    const s=worldToScreen(p);
    ctx.save(); ctx.fillStyle=color;
    ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function centroid(pts){
    let x=0,y=0; for(const p of pts){x+=p.x;y+=p.y;} return {x:x/pts.length,y:y/pts.length};
  }
  function drawLabel(p,text,color){
    const s=worldToScreen(p);
    ctx.save();
    ctx.font="12px ui-sans-serif,system-ui";
    const pad=6; const w=ctx.measureText(text).width;
    ctx.fillStyle="rgba(0,0,0,.55)";
    ctx.fillRect(s.x-w/2-pad, s.y-18, w+pad*2, 18);
    ctx.fillStyle=color||"rgba(255,255,255,.9)";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(text, s.x, s.y-9);
    ctx.restore();
  }
  function drawPoly(pts, fill, stroke, lw, closed, label){
    if(!pts || pts.length<2) return;
    ctx.save();
    ctx.beginPath();
    const p0=worldToScreen(pts[0]);
    ctx.moveTo(p0.x,p0.y);
    for(let i=1;i<pts.length;i++){
      const pi=worldToScreen(pts[i]);
      ctx.lineTo(pi.x,pi.y);
    }
    if(closed && pts.length>=3) ctx.closePath();
    if(fill){ ctx.fillStyle=fill; ctx.fill(); }
    ctx.strokeStyle=stroke; ctx.lineWidth=lw; ctx.stroke();
    ctx.restore();
    if(label && pts.length>=3) drawLabel(centroid(pts), label, stroke);
  }

  function drawGrid(){
    const step=50;
    const topLeft=screenToWorld({x:0,y:0});
    const bottomRight=screenToWorld({x:cssW,y:cssH});
    const startX=Math.floor(topLeft.x/step)*step;
    const startY=Math.floor(topLeft.y/step)*step;
    const endX=Math.ceil(bottomRight.x/step)*step;
    const endY=Math.ceil(bottomRight.y/step)*step;
    for(let x=startX;x<=endX;x+=step) drawLine({x,y:startY},{x,y:endY},'rgba(255,255,255,.06)',1);
    for(let y=startY;y<=endY;y+=step) drawLine({x:startX,y},{x:endX,y},'rgba(255,255,255,.06)',1);
  }

  function drawWet(){
    const {data,w,h} = state.wet.data;
    const {minX,minY,cellPx} = state.wet.bbox;
    for(let j=0;j<h;j++){
      for(let i=0;i<w;i++){
        const c = data[j*w+i];
        if(c<=0) continue;

        // Blue intensity: 1 = light, 2 = darker, 3+ = darkest
        let a = 0.18;
        if(c===1) a = 0.18;
        else if(c===2) a = 0.32;
        else a = 0.48;

        const x = minX + i*cellPx;
        const y = minY + j*cellPx;
        const p = worldToScreen({x,y});

        ctx.save();
        ctx.fillStyle = `rgba(80,160,255,${a})`;
        ctx.fillRect(p.x, p.y, cellPx*view.s+0.5, cellPx*view.s+0.5);
        ctx.restore();
      }
    }
  }

  function drawSource(s){
    const p=worldToScreen({x:s.x,y:s.y});
    ctx.save();
    ctx.fillStyle='rgba(52,211,153,.95)';
    ctx.beginPath(); ctx.arc(p.x,p.y,7,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='rgba(52,211,153,.55)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(p.x,p.y,16,0,Math.PI*2); ctx.stroke();
    ctx.font='12px ui-sans-serif,system-ui';
    ctx.fillStyle='rgba(230,237,243,.9)';
    ctx.fillText(`${s.name}`, p.x+10, p.y-18);
    if(s.info) ctx.fillText(`${s.info}`, p.x+10, p.y-3);
    ctx.restore();
  }

  function drawSprinkler(s, isPreview=false){
    if(!state.scale.pxPerMeter) return;
    const pr=presetByKey(s.presetKey);
    const p=worldToScreen({x:s.x,y:s.y});
    const rr=(s.radiusM*state.scale.pxPerMeter)*view.s;

    const arc=(s.arcDeg||360)*Math.PI/180;
    const dir=(s.dirDeg||0)*Math.PI/180;
    const start=dir-arc/2, end=dir+arc/2;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(p.x,p.y);
    ctx.arc(p.x,p.y,rr,start,end);
    ctx.closePath();

    ctx.fillStyle = isPreview ? 'rgba(76,201,240,.12)' : 'rgba(76,201,240,.08)';
    ctx.fill();

    ctx.strokeStyle = isPreview ? 'rgba(167,139,250,.85)' : 'rgba(76,201,240,.55)';
    ctx.lineWidth = isPreview ? 2.5 : 1.6;
    ctx.stroke();

    ctx.fillStyle = isPreview ? 'rgba(167,139,250,.95)' : 'rgba(76,201,240,.95)';
    ctx.beginPath(); ctx.arc(p.x,p.y,4.5,0,Math.PI*2); ctx.fill();

    const zn = state.zones.find(z=>z.id===s.zoneId)?.name || "";
    ctx.font='12px ui-sans-serif,system-ui';
    ctx.fillStyle='rgba(230,237,243,.9)';
    ctx.textAlign='left'; ctx.textBaseline='top';
    ctx.fillText(`${pr.label} ‚Ä¢ ${s.radiusM.toFixed(1)}m ‚Ä¢ ${zn}`, p.x+8, p.y+6);

    ctx.restore();
  }

  function drawPipes(){
    for(const p of state.pipes){
      drawPoly(p.pts,null,'rgba(251,191,36,.75)',3,false,null);
      if(p.pts?.length){
        drawLabel(p.pts[Math.floor(p.pts.length/2)], `${p.name} ‚Ä¢ ${p.dia}mm`, 'rgba(251,191,36,.95)');
      }
    }
  }

  function drawSnapIndicator(){
    if(!(tool==='pipe' && drawing.kind==='pipe')) return;
    if(!drawing.snap) return;
    const s=worldToScreen({x:drawing.snap.x,y:drawing.snap.y});
    ctx.save();
    ctx.strokeStyle='rgba(167,139,250,.95)';
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(s.x,s.y,18,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle='rgba(167,139,250,.95)';
    ctx.font='12px ui-sans-serif,system-ui';
    ctx.fillText("SNAP", s.x+22, s.y-6);
    ctx.restore();
  }

  function render(){
    ctx.clearRect(0,0,cssW,cssH);

    // bg
    if(state.bg.img){
      const p0=worldToScreen({x:0,y:0});
      ctx.drawImage(state.bg.img, p0.x, p0.y, state.bg.w*view.s, state.bg.h*view.s);
    }

    if(state.showGrid) drawGrid();
    if(state.showWet && state.wet.ready) drawWet();

    // areas
    for(const a of state.areas){
      drawPoly(a.pts,'rgba(76,201,240,.14)','rgba(76,201,240,.90)',2,true,a.name);
    }

    // pipes
    drawPipes();

    // drawing preview
    if(drawing.kind && drawing.pts.length){
      const pts = drawing.temp ? [...drawing.pts, drawing.temp] : drawing.pts;
      if(drawing.kind==='pipe'){
        drawPoly(pts,null,'rgba(251,191,36,1)',3,false,null);
        drawPoint(drawing.pts[0],'rgba(251,191,36,.95)',6);
      } else if(drawing.kind==='area'){
        drawPoly(pts,'rgba(76,201,240,.06)','rgba(76,201,240,1)',2,false,null);
        drawPoint(drawing.pts[0],'rgba(76,201,240,1)',6);
      }
    }

    // scale points
    if(state.scale.a) drawPoint(state.scale.a,'rgba(251,191,36,.95)',6);
    if(state.scale.b) drawPoint(state.scale.b,'rgba(251,191,36,.95)',6);
    if(state.scale.a && state.scale.b){
      drawLine(state.scale.a,state.scale.b,'rgba(251,191,36,.9)',2);
      const dpx=dist(state.scale.a,state.scale.b);
      const txt = state.scale.pxPerMeter ? `${(dpx/state.scale.pxPerMeter).toFixed(2)} m` : `${dpx.toFixed(0)} px`;
      drawLabel({x:(state.scale.a.x+state.scale.b.x)/2, y:(state.scale.a.y+state.scale.b.y)/2}, txt, 'rgba(251,191,36,.95)');
    }

    // source
    if(state.source) drawSource(state.source);

    // sprinklers
    for(const s of state.sprinklers) drawSprinkler(s,false);

    // live preview sprinkler
    if(liveSpr?.active) drawSprinkler(liveSpr.data,true);

    drawSnapIndicator();

    // selection highlight
    if(state.selection?.kind==='sprinkler'){
      const s=getSel('sprinkler');
      if(s) drawPoint({x:s.x,y:s.y},'rgba(167,139,250,1)',10);
    }
    if(state.selection?.kind==='source'){
      const s=getSel('source');
      if(s) drawPoint({x:s.x,y:s.y},'rgba(52,211,153,1)',10);
    }
  }

  // Init UI and actions
  fillPresetSelect();
  renderZones();
  updateSprZoneOptions();
  updateCurStepBox();
  renderSteps();
  injectAutoPipeButton();
  buildBOM();
  recalcWet();

  // tool default
  setTool('pan');

  // Re-inject auto pipe button after steps re-render
  const _oldRenderSteps = renderSteps;
  renderSteps = function(){
    _oldRenderSteps();
    injectAutoPipeButton();
  };

  // Sprinkle preset select options also when none selected: keep default
  el('sprPreset').addEventListener('change', ()=>{
    const selSpr=getSel('sprinkler');
    if(!selSpr){
      const val=el('sprPreset').value;
      const pr=presetByKey(val);
      state.defaultSpr.presetKey=val;
      if(val!=="CUSTOM"){
        state.defaultSpr.radiusM=pr.radiusM;
        state.defaultSpr.name=`Regner ${pr.label}`;
      }
    }
  });

  // Update selection props on click if not dragging
  canvas.addEventListener('click', (e)=>{
    if(mouse.down) return;
    const w=screenToWorld({x:e.offsetX,y:e.offsetY});
    const hit=hitTest(w);
    if(hit){
      state.selection=hit;
      showProps();
      render();
    }
  });

  // Keep canvas sized
  fitCanvas();
  render();
})();
</script>
</body>
</html>
